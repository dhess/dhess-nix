{ lib, pkgs }:

with lib;

{
  #enable = mkEnableOption "Enable a full-tunnel WireGuard VPN server.";

  description = ''
    A declarative WireGuard "full-tunnel" VPN server.

    IPv4 traffic that is routed to a full-tunnel WireGuard server will
    be NATed to the server's public IPv4 address. IPv6 traffic will be
    routed normally and clients will be given a public IPv6 address
    from the pool assigned to the WireGuard server.
  '';

  interface = mkOption {
    type = pkgs.lib.types.nonEmptyStr;
    default = "wg0";
    description = ''
      The WireGuard interface on which this WireGuard VPN will run, of
      the form <literal>wg<replaceable>N</replaceable></literal>.
    '';
  };

  listenPort = mkOption {
    default = 51820;
    type = pkgs.lib.types.port;
    example = 22883;
    description = ''
      The UDP port on which the WireGuard server will listen for
      incoming connections.
    '';
  };

  ipv4ClientCidr = mkOption {
    type = pkgs.lib.types.ipv4CIDR;
    example = "10.0.1.0/24";
    description = ''
      The base of the IPv4 address range that will be assigned to
      WireGuard clients, in CIDR format.
    '';
  };

  ipv6ClientPrefix = mkOption {
    type = pkgs.lib.types.ipv6CIDR;
    example = "2001:DB8::1:0/112";
    description = ''
      The IPv6 prefix from which IPv6 addresses will
      be assigned for clients of the WireGuard service.
    '';
  };

  privateKeyLiteral = mkOption {
    type = pkgs.lib.types.nonEmptyStr;
    example = "<key>";
    description = ''
      The WireGuard server's private key, as a string literal, as
      generated by the command <command>wg genkey</command>. Note that
      this secret will not be copied to the Nix store. However, uppon
      start-up, the service will copy a file containing the key to its
      persistent state directory.
    '';
  };

  peers = mkOption {
    default = {};
    description = ''
      Peers linked to the WireGuard interface.
    '';
    type = types.attrsOf (types.submodule (
    { config, options, name, ... }:
    {
      options = {

        name = mkOption {
          type = pkgs.lib.types.nonEmptyStr;
          default = "${name}";
          description = ''
            A short name for the peer. The name should be a valid
            <literal>systemd</literal> service name (i.e., no spaces,
            no special characters, etc.); the service that sets up the
            peer's configuration will be named
            <literal>wireguard-<option>interface</option>-<replaceable>name</replaceable>-setup.service</literal>.

            If undefined, the name of the attribute set will be used.
          '';
        };

        allowedIPs = mkOption {
          example = literalExample [
            { ip = "10.192.122.3/32"; route.enable = true; }
          ];
          type = types.listOf pkgs.lib.types.wgAllowedIP;
          description = ''
            List of IP addresses (and optional routes) for IPs that are
            allowed on this WireGuard interface.
          '';
        };

        natInternalIPs = mkOption {
          example = [ "10.192.122.3/32" "10.192.124.1/24" ];
          default = [];
          type = types.listOf pkgs.lib.types.ipv4RFC1918CIDR;
          description = ''
            List of RFC1918 IPv4 addresses, in CIDR format. Traffic from these
            IPs is NATed by the WireGuard server, assuming the traffic from
            these IPs is allowed for this peer in the first place (i.e.,
            assuming these IPs are in the <literal>allowedIPs</literal>
            range).

            In most cases, this list should be the subset of RFC1918 IPv4
            addresses in the <literal>allowedIPs</literal> list, unless
            you want traffic from any of those address ranges not to be
            NATed and routed to the public Internet.
          '';
        };

        endpoint = mkOption {
          default = null;
          example = "demo.wireguard.io:12913";
          type = with types; nullOr str;
          description = ''Endpoint IP or hostname of the peer, followed by a colon,
          and then a port number of the peer.'';
        };

        publicKeyFile = mkOption {
          example = literalExample ./peer-pubkey;
          type = types.path;
          description = ''
            A file containing the peer's public key.
          '';
        };

        presharedKeyLiteral = mkOption {
          type = pkgs.lib.types.nonEmptyStr;
          example = "<key>";
          description = ''
            The WireGuard pre-shared key for this peer, as a string
            literal, as generated by the command <command>wg
            genpsk</command>. Note that this secret will not be copied
            to the Nix store. However, upon start-up, the service will
            copy a file containing the key to its persistent state
            directory.
         '';
        };
      };
    }));
  };
}
