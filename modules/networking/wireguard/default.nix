## This module improves upon the Nixpkgs module by using better
## typesafety, requiring peer PSKs, and ensuring that PSKs and private
## keys aren't written to the Nix store.
##
## It also eliminiates the global table and allowedIPsAsRoutes options
## and moves those to a per-allowed IP setting.

{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.networking.wireguard;
  keys = config.quixops.keychain.keys;

  kernel = config.boot.kernelPackages;

  stateDir = "/var/lib/wireguard";
  keyName = name: "wireguard-${name}-key";
  pskName = name: peer: "wireguard-${name}-${peer}-psk";

  # interface options

  interfaceOpts = { name, ... }: {

    options = {

      ips = mkOption {
        example = [ "192.168.2.1/24" "2001:DB8::1:0/112" ];
        default = [];
        type = types.listOf (types.either pkgs.lib.types.ipv4CIDR pkgs.lib.types.ipv6CIDR);
        description = "The IP addresses of the interface.";
      };

      privateKeyLiteral = mkOption {
        type = pkgs.lib.types.nonEmptyStr;
        example = "<key>";
        description = ''
          The WireGuard server's private key, as a string literal, as
          generated by the command <command>wg genkey</command>. Note that
          this secret will not be copied to the Nix store. However, uppon
          start-up, the service will copy a file containing the key to its
          persistent state directory.
        '';
      };

      listenPort = mkOption {
        default = null;
        type = with types; nullOr pkgs.lib.types.port;
        example = 51820;
        description = ''
          UDP port for listening. Optional; if not specified,
          automatically generated based on interface name.
        '';
      };

      preSetup = mkOption {
        example = literalExample ''
          ${pkgs.iproute}/bin/ip netns add foo
        '';
        default = "";
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        description = ''
          Commands called at the start of the interface setup.
        '';
      };

      postSetup = mkOption {
        example = literalExample ''
          printf "nameserver 10.200.100.1" | ${pkgs.openresolv}/bin/resolvconf -a wg0 -m 0
        '';
        default = "";
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        description = "Commands called at the end of the interface setup.";
      };

      postShutdown = mkOption {
        example = literalExample "${pkgs.openresolv}/bin/resolvconf -d wg0";
        default = "";
        type = with types; coercedTo (listOf str) (concatStringsSep "\n") lines;
        description = "Commands called after shutting down the interface.";
      };

      peers = mkOption {
        default = {};
        description = "Peers linked to the interface.";
        type = types.attrsOf pkgs.lib.types.wgPeer;
      };
    };

  };

  generateUnit = name: values:
    nameValuePair "wireguard-${name}"
      {
        description = "WireGuard Tunnel - ${name}";
        wants = [ "keys.target" ];
        requires = [ "network-online.target" ];
        after = [ "network.target" "network-online.target" "keys.target" ];
        wantedBy = [ "multi-user.target" ];
        environment.DEVICE = name;
        path = with pkgs; [ kmod iproute wireguard-tools ];

        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = true;
        };

        script =
        let
          keyPath = keys."${keyName name}".path;
          peers = mapAttrsToList (_: peer: peer) values.peers;
        in
        ''
	  ${optionalString (!config.boot.isContainer) "modprobe wireguard"}

          ${values.preSetup}

          ip link add dev ${name} type wireguard

          ${concatMapStringsSep "\n" (ip:
            "ip address add ${ip} dev ${name}"
          ) values.ips}

          wg set ${name} private-key ${keyPath} ${
            optionalString (values.listenPort != null) " listen-port ${toString values.listenPort}"}

          ${concatMapStringsSep "\n" (peer:
            let
              pskPath = keys."${pskName name peer.name}".path;
              allowedIPs = map (allowedIP: allowedIP.ip) peer.allowedIPs;
            in
              "wg set ${name} peer ${peer.publicKey}" +
              " preshared-key ${pskPath}" +
              optionalString (peer.endpoint != null) " endpoint ${peer.endpoint}" +
              optionalString (peer.persistentKeepalive != null) " persistent-keepalive ${toString peer.persistentKeepalive}" +
              optionalString (allowedIPs != []) " allowed-ips ${concatStringsSep "," allowedIPs}"
            ) peers}

          ip link set up dev ${name}

          ${concatMapStringsSep "\n"
              (peer:
                concatMapStringsSep
                  "\n"
                  (allowedIP:
                    optionalString allowedIP.route.enable "ip route replace ${allowedIP.ip} dev ${name} table ${allowedIP.route.table}")
                  peer.allowedIPs)
              peers}

          ${values.postSetup}
        '';

        postStop = ''
          ip link del dev ${name}
          ${values.postShutdown}
        '';
      };

in

{

  disabledModules = [ "services/networking/wireguard.nix" ];

  ###### interface

  options = {

    networking.wireguard = {

      interfaces = mkOption {
        description = "Wireguard interfaces.";
        default = {};
        example = {
          wg0 = {
            ips = [ "192.168.20.4/24" ];
            privateKeyLiteral = "yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=";
            peers.demo =
              { allowedIPs = [ "192.168.20.1/32" ];
                presharedKeyLiteral = "tSOLSmehg25TvZghw4R2uIgDrkXh0PEvDupZcXrRNEc=";
                publicKey  = "xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=";
                endpoint   = "demo.wireguard.io:12913"; };
          };
        };
        type = with types; attrsOf (submodule interfaceOpts);
      };

    };

  };


  ###### implementation

  config = mkIf (cfg.interfaces != {}) {

    quixops.assertions.moduleHashes."services/networking/wireguard.nix" =
      "7ee71ebb08976efceb1d4452fb3babdc3a007e9fa6f21057ee79ab1b1ff70e43";

    boot.extraModulePackages = [ kernel.wireguard ];
    environment.systemPackages = [ pkgs.wireguard-tools ];

    systemd.services = (mapAttrs' generateUnit cfg.interfaces);

    quixops.keychain.keys = listToAttrs (filter (x: x.value != null) (
      (mapAttrsToList
        (ifname: values: nameValuePair (keyName ifname) ({
          destDir = stateDir;
          text = values.privateKeyLiteral;
        })) cfg.interfaces) ++
      (lib.flatten
        (mapAttrsToList
          (ifname: values:
            mapAttrsToList
              (peer: values: nameValuePair (pskName ifname peer) ({
                destDir = stateDir;
                text = values.presharedKeyLiteral;
              }))
              values.peers)
          cfg.interfaces))
      ));

  };

}
